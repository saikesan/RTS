#include <Windows.h>
#include <stdio.h>
#include <iostream>


/*
 * Как работает семафор:
 * 
 * У семфора есть количество объектов семфора (параметр у него такой и именно так называется).
 * Это кол-во можно изменять. Семафор может быть в сигнальном состоянии и в не сигнальном.
 * Сигнальное состояние выставляется когда кол-во объектов больше 0. Это делается вызовом функции ReleaseSemaphore.
 * Не сигнальное состояние выставляется когда кол-во объектов равно 0.
 * С помощью этого мы синхронизируем процессы.
 * 
 * На сервре создаем семафор, с изначальным кол-вом объектов 0, что бы он был в не сигнальном состоянии. 
 * Из-за чего функция WaitForSingleObject поставит наш поток программы на паузу (программа перестанет выполняться на этой функции), 
 * когда мы передадим в нее наш семафор.
 * Потом в клиенте мы вызовем функцию ReleaseSemaphore, которая увеличит кол-во объектов семафора, после чего 
 * функция WaitForSingleObject уменьшит кол-во объектов на 1 и наш поток сервера разблокируется. и программа сервера
 * снова в цикле встанет в ожидании.
 */


// Размер памяти буфера разделяемой памяти.
#define MAPPED_MEMORY_SIZE 1024

// Имя создаваемого объекта семафора, для работы с ним из других процессов.
LPCWSTR semaphoreName = TEXT("Global\\mySemaphore");

// Имя создаваемого объекта разделяемой памяти, для работы с ней из других процессов.
LPCWSTR fileMapName = TEXT("Global\\myFileMap");

// Максимальное количество открытых объектов семафора.
const int sphMaxObjCount = 2;



int main()
{
	HANDLE semaphore = NULL;
	HANDLE fileMap = NULL;
	LPCTSTR fileMemory = NULL;
	std::string msg;

	// Создание объекта разделяемой памяти. Сейчас создаем его именованым, за это отвечает последний параметр (fileMapName).
	// Создаем именованым, чтобы могли использовать в других процессах (клиентах).
	fileMap = CreateFileMapping
	(
		INVALID_HANDLE_VALUE, // описатель файла из которого создается раздеяемая память (Это в случае если мы будем создавать объект на основе файла в файловой системе, но мы создаем на основе системного файла подкачки, поэтому передаем такое значение как INVALID_HANDLE_VALUE).
		NULL,				  // описатель структуры безопасности (нужно передавать указатель на струкутуру безопасности, если хотим чтобы этот описатель использовали дочернии для этого процесса процессы, мы делаем клинет-сервер, поэтому у нас не дочерние процессы, значит передаем NULL, чтобы наследования не было).
		PAGE_READWRITE,		  // режим открытия объекта (у нас на чтение и запись).
		0,					  // старшее слово размера буфера.
		MAPPED_MEMORY_SIZE,	  // младшее слово.
		fileMapName			  // имя создаваемого объекта.
	);

	if (fileMap == NULL) // проверка на то, что создали объект.
	{
		printf("Create file mapping error: %d", GetLastError());

		return -1;
	}

	// Создание обекта семафора. Сейчас создаем его именованым, за это отвечает последний параметр (semaphoreName).
	// Создаем именованым, чтобы могли использовать в других процессах (клиентах).
	semaphore = CreateSemaphore
	(
		NULL,			// описатель структуры безопасности.
		0,				// начальное количество открытых объектов семафоров.
		sphMaxObjCount, // максимальное количество открытых объектов семафоров.
		semaphoreName	// имя семафора.
	);

	if (semaphore == NULL) // проверка на то, что создали объект.
	{
		printf("Semaphore creating error: %d", GetLastError());

		return -1;
	}

	// В цикле для 2 клиентов ожидаем от них сообщений.
	for (size_t i = 0; i < static_cast<size_t>(sphMaxObjCount); i++)
	{
		printf("Server is waiting message from %I64u client...\n", i + 1);

		// Здесь поток процесса сервера блокируется (программа просто встает на паузу в этом месте) и ожидает вызова функции ReleaseSemaphore(), для нашего семафора
		// мы эту функцию вызываем в клиенте. Функция ReleaseSemaphore увеливает количество объектов семфора (которые мы изначально задали 0).
		// 
		// Сама функция WaitForSingleObject бесконечно (INFINITE) ожидает когда вызовется функция ReleaseSemaphore 
		// для того, что бы уменьшить количетсво объектов семафора на 1.
		// Как только вызовется ReleaseSemaphore поток разблокируется, и программа будет выполняться далее.
		WaitForSingleObject(semaphore, INFINITE);
		printf("%I64u client write\n", i + 1);

		// получаем указатель на область памяти нашей разделяемой памяти, чтобы мы могли в нее что то писать.
		fileMemory = (LPTSTR)MapViewOfFile
		(
			fileMap,			 // описатель разделяемой памяти на которую будем получать указатель.
			FILE_MAP_ALL_ACCESS, // режимы доступа к памяти (мы можем писать и читать).
			0,					 // смещение внутри разделяемой памяти (по сути выбираем блок разделяемой памяти в который будем писать или читать(если еще понятнее - с какого места в раздеяемой памяти от ее начала будем писать)) старшее слово.
			0,					 // смещение внутри разделяемой памяти (по сути выбираем блок разделяемой памяти в который будем писать или читать(если еще понятнее - с какого места в раздеяемой памяти от ее начала будем писать)) младшее слово.
			MAPPED_MEMORY_SIZE	 // размер области
		);

		if (fileMemory == NULL) // проверяем получили ли указатель.
		{
			printf("Could not map view of file %d.\n", GetLastError());

			CloseHandle(fileMap);

			return 1;
		}

		msg = (char*)fileMemory; // получаем данный из разделяемой памяти.
		std::cout << msg << "\n\n"; // выводим.

		UnmapViewOfFile(fileMemory); // освобождаем получаенный указатель.
	}

	// Освобождаем описатели.
	CloseHandle(fileMap);
	CloseHandle(semaphore);

	return 0;
}